"use strict";(self.webpackChunktracetest_docs=self.webpackChunktracetest_docs||[]).push([[3126],{40350:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=n(74848),i=n(28453);const a={id:"creating-tests",title:"Defining Tests as Text Files",description:"Tracetest enables developers to define tests as text files and run them using a CLI. Integrate the execution of tests in your existing CI pipeline.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},r=void 0,o={id:"cli/creating-tests",title:"Defining Tests as Text Files",description:"Tracetest enables developers to define tests as text files and run them using a CLI. Integrate the execution of tests in your existing CI pipeline.",source:"@site/docs/cli/creating-tests.mdx",sourceDirName:"cli",slug:"/cli/creating-tests",permalink:"/cli/creating-tests",draft:!1,unlisted:!1,editUrl:"https://github.com/kubeshop/tracetest/blob/main/docs/docs/cli/creating-tests.mdx",tags:[],version:"current",frontMatter:{id:"creating-tests",title:"Defining Tests as Text Files",description:"Tracetest enables developers to define tests as text files and run them using a CLI. Integrate the execution of tests in your existing CI pipeline.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},sidebar:"tutorialSidebar",previous:{title:"Defining Data Stores as Text Files",permalink:"/cli/creating-data-stores"},next:{title:"Defining HTTP Tests as Text Files",permalink:"/cli/creating-tests-http"}},l={},c=[{value:"Motivation",id:"motivation",level:2},{value:"Definition",id:"definition",level:2},{value:"Test Information",id:"test-information",level:2},{value:"Trigger",id:"trigger",level:2},{value:"Specs",id:"specs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Defining a polling profile",id:"defining-a-polling-profile",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"One important aspect of testing your code is the ability to quickly implement changes while not breaking your application. If you change your application, it is important to be able to update your tests and run them against your new implementation as soon as possible for a timely development feedback loop."}),"\n",(0,s.jsx)(t.p,{children:"As Tracetest is mainly a visual tool, this might make it difficult to update tests in an auditable way and execute those changes only when we are sure the application has been deployed with the new changes. With that in mind, we built a new way for you to define your tests: using a YAML test definition!"}),"\n",(0,s.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsxs)(t.p,{children:["Imagine that you were assigned a ticket to improve your application database usage. You notice that every time a specific endpoint is called, your application executes ",(0,s.jsx)(t.code,{children:"N+1"})," select statements on the database instead of only one statement. You probably already have a test in place to ensure the correct functionality of that endpoint: it inserts the necessary information into the database, calls that specific endpoint using our tool and ensures you get the expected results using the trace generated by your application. It works fine, but there is a problem. That test is managed by Tracetest on its server and the test cannot be changed until the new patch is deployed. Otherwise, if the test is run using a non-patched version of the application, the test would fail."]}),"\n",(0,s.jsx)(t.p,{children:"To solve that, the best approach would be to enable developers to define their tests as text files and allow them to run those tests using a CLI, so you can integrate the execution of those tests to your existing CI pipeline. There are many benefits of this functionality for your tests:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Peers can review your tests before merging them to the main branch."}),"\n",(0,s.jsx)(t.li,{children:"Ensure your test works before merging it to the main branch."}),"\n",(0,s.jsx)(t.li,{children:"Have different versions of the same test running in parallel in different branches, so you and your peers can work on the same code modules and update the same test without interfering with each other."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(t.p,{children:["The definition can be broken into three parts: ",(0,s.jsx)(t.code,{children:"test information"})," including ",(0,s.jsx)(t.code,{children:"triggering transaction"}),", ",(0,s.jsx)(t.code,{children:"assertions"}),", and ",(0,s.jsx)(t.code,{children:"outputs"}),". Here is a real test we have on Tracetest to test our ",(0,s.jsx)(t.a,{href:"/live-examples/pokeshop/overview",children:"Pokeshop Demo API"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'type: Test\nspec:\n  name: DEMO Pokemon - Import - Import a Pokemon\n  description: "Import a pokemon"\n  trigger:\n    type: http\n    httpRequest:\n      url: http://demo-pokemon-api.demo/pokemon/import\n      method: POST\n      headers:\n      - key: Content-Type\n        value: application/json\n      body: \'{ "id": 52 }\'\n  specs:\n    - selector: span[name = "POST /pokemon/import"]\n      assertions:\n        - attr:tracetest.span.duration <= 500ms\n        - attr:http.status_code = 200\n    - selector: span[name = "send message to queue"]\n      assertions:\n        - attr:messaging.message.payload contains 52\n    - selector: span[name = "consume message from queue"]:last\n      assertions:\n        - attr:messaging.message.payload contains 52\n    - selector: span[name = "consume message from queue"]:last span[name = "import pokemon\n        from pokeapi"]\n      assertions:\n        - attr:http.status_code = 200\n    - selector: span[name = "consume message from queue"]:last span[name = "save pokemon\n        on database"]\n      assertions:\n        - attr:db.repository.operation = "create"\n        - attr:tracetest.span.duration <= 500ms\n  outputs:\n    - name: POKEMON_ID\n      selector: span[name = "POST /pokemon/import"]\n      value: attr:http.response.body | json_path \'.id\'\n\n'})}),"\n",(0,s.jsx)(t.h2,{id:"test-information",children:"Test Information"}),"\n",(0,s.jsx)(t.p,{children:"Currently, you can define:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"test name"}),"\n",(0,s.jsx)(t.li,{children:"test description"}),"\n",(0,s.jsx)(t.li,{children:"test id (if it is known)"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"trigger",children:"Trigger"}),"\n",(0,s.jsx)(t.p,{children:"This section defines how Tracetest will interact with your application. You can send an HTTP request, a GRPC call, send a message to a message broker, use an existing TraceID, etc."}),"\n",(0,s.jsxs)(t.p,{children:["The attribute ",(0,s.jsx)(t.code,{children:"type"})," defines which trigger method you are going to use to interact with your application. The rest of the attributes in this section rely on the value you define there."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"trigger:\n  type: http|grpc|kafka|traceid|cypress|playwright|k6|artillery\n"})}),"\n",(0,s.jsx)(t.p,{children:"Choose the kind of trigger to initiate the trace:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-http",children:"HTTP Request - Create a basic HTTP request."})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-grpc",children:"GRPC Request - Test and debug your GRPC request."})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-kafka",children:"Kafka - Test consumers with Kafka messages."})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-playwright-engine",children:"Playwright Engine - Run Playwright tests natively in Tracetest."})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-graphql",children:"GraphQL - Test and debug your GraphQL request."})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/cli/creating-tests-traceid",children:"TraceID - Define your test via a TraceID."})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Or, choose to use an external integration to trigger Tracetest:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/web-ui/creating-tests-cypress",children:"Cypress"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/web-ui/creating-tests-playwright",children:"Playwright"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/web-ui/creating-tests-k6",children:"k6"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/web-ui/creating-tests-artillery",children:"Artillery"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"specs",children:"Specs"}),"\n",(0,s.jsxs)(t.p,{children:["This section defines test specifications. You can use the ",(0,s.jsx)(t.a,{href:"/concepts/selectors",children:"selector language"})," to pick which spans to test against. Then, use the ",(0,s.jsx)(t.a,{href:"/concepts/assertions",children:"assertions"})," to validate attribute values."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'specs:\n  - selector: span[tracetest.span.type="http"]\n    name: "All HTTP Spans: Status  code is 200"\n    assertions:\n    - attr:http.status_code   =   200\n  - selector: span[tracetest.span.type="database"]\n    name: "All Database Spans: Processing time is less than 100ms"\n    assertions:\n    - attr:tracetest.span.duration < 2s\n'})}),"\n",(0,s.jsx)(t.h2,{id:"outputs",children:"Outputs"}),"\n",(0,s.jsx)(t.p,{children:"This section defines test outputs. You can define an output value from a test to use as input for subsequent tests."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'outputs:\n  - name: MY_OUTPUT\n    selector: span[tracetest.span.type="general" name="Tracetest trigger"]\n    value: attr:name\n'})}),"\n",(0,s.jsx)(t.h2,{id:"defining-a-polling-profile",children:"Defining a polling profile"}),"\n",(0,s.jsx)(t.p,{children:"Some tests have different requirements than others, it means that some will take longer to run than other tests, so it's crucial to be able to define the trace polling strategy at the test level."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"type: Test\nspec:\n  name: my test\n  pollingProfile: ./my-polling-profile.yaml\n  trigger: http\n  httpRequest:\n    ...\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will make all runs from this test to use this specific test profile, and in case no value is defined, the test will use your default polling profile."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);