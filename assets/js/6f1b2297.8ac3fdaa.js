"use strict";(self.webpackChunktracetest_docs=self.webpackChunktracetest_docs||[]).push([[3610],{85856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=n(74848),r=n(28453);const a={id:"sampling-tracetest-spans",title:"Sampling Tracetest Spans",description:"When running Tracetest in production, your test spans could not be sampled by your probabilistic sampler. Here's how to avoid sampling out Tracetest test spans.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},o=void 0,i={id:"configuration/sampling-tracetest-spans",title:"Sampling Tracetest Spans",description:"When running Tracetest in production, your test spans could not be sampled by your probabilistic sampler. Here's how to avoid sampling out Tracetest test spans.",source:"@site/docs/configuration/sampling-tracetest-spans.mdx",sourceDirName:"configuration",slug:"/configuration/sampling-tracetest-spans",permalink:"/configuration/sampling-tracetest-spans",draft:!1,unlisted:!1,editUrl:"https://github.com/kubeshop/tracetest/blob/main/docs/docs/configuration/sampling-tracetest-spans.mdx",tags:[],version:"current",frontMatter:{id:"sampling-tracetest-spans",title:"Sampling Tracetest Spans",description:"When running Tracetest in production, your test spans could not be sampled by your probabilistic sampler. Here's how to avoid sampling out Tracetest test spans.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},sidebar:"tutorialSidebar",previous:{title:"Demo Settings",permalink:"/configuration/demo"},next:{title:"Configuring Trace Ingestion",permalink:"/web-ui/creating-data-stores"}},c={},l=[{value:"Add a Separate Pipeline for Tracetest in your OpenTelemetry Collector",id:"add-a-separate-pipeline-for-tracetest-in-your-opentelemetry-collector",level:2},{value:"Tail Sampling Approach",id:"tail-sampling-approach",level:3},{value:"Consider Trace-related Headers in your Ingress Endpoint",id:"consider-trace-related-headers-in-your-ingress-endpoint",level:2}];function p(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Suppose you are considering Tracetest to run tests against a high-volume environment, such as production. In that case, you probably will hit some drawbacks, such as having\nyour test spans not sampled by your probabilistic sampler. There are a couple of things that you can do to avoid those problems:"}),"\n",(0,s.jsx)(t.h2,{id:"add-a-separate-pipeline-for-tracetest-in-your-opentelemetry-collector",children:"Add a Separate Pipeline for Tracetest in your OpenTelemetry Collector"}),"\n",(0,s.jsx)(t.p,{children:"Your existing OpenTelemetry Collector already receives traces from your applications and sends them to your datastore and you have a set of processors configured to ensure the quality of the traces your datastore is receiving. It probably looks like this one:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"receivers:\n  otlp:\n    protocols:\n      grpc:\n      http:\n\nprocessors:\n  probabilistic_sampler:\n    hash_seed: 22\n    sampling_percentage: 5.0\n\n  batch:\n\nexporters:\n  otlp/jaeger:\n    endpoint: jaeger:4317\n    tls:\n      insecure: true\n\nservice:\n  pipelines:\n    traces/jaeger:\n      receivers: [otlp]\n      processors: [tail_sampling, batch]\n      exporters: [otlp/jaeger]\n"})}),"\n",(0,s.jsx)(t.p,{children:"We don't want to change this pipeline for your testing to work, so let's create a new pipeline for collecting only traces generated by Tracetest tests:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'receivers:\n  otlp:\n    protocols:\n      grpc:\n      http:\n\nprocessors:\n  batch:\n\n  probabilistic_sampler:\n    hash_seed: 22\n    sampling_percentage: 5.0\n\n  # If this configuration fails on your collector, make sure to update it to a newer version.\n  # This is the recommended way of filtering spans based on the `trace_state`. It\'s faster and less\n  # resource intensive than using a `tail_sampling` approach.\n  filter/tracetest:\n    error_mode: ignore\n    traces:\n      span:\n        - \'trace_state["tracetest"] != "true"\'\n\nexporters:\n  otlp/jaeger:\n    endpoint: jaeger:4317\n    tls:\n      insecure: true\n\nservice:\n  pipelines:\n    traces/jaeger:\n      receivers: [otlp]\n      processors: [tail_sampling, batch]\n      exporters: [otlp/jaeger]\n\n  pipelines:\n    traces/tracetest:\n      receivers: [otlp]\n      processors: [filter/tracetest, batch]\n      exporters: [otlp/jaeger]\n'})}),"\n",(0,s.jsx)(t.h3,{id:"tail-sampling-approach",children:"Tail Sampling Approach"}),"\n",(0,s.jsxs)(t.p,{children:["Before December 2023, we were suggesting people to use tail sampling to filter the traces generated by Tracetest.\nHowever, the new ",(0,s.jsx)(t.code,{children:"filter"})," capabilities are better for performance than tail sampling as it\nrequires less memory to decide if a trace should be sampled or not. If you are not concerned with memory usage and still want to use the\ntail sampling approach, this is the processor you can use:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'processors:\n  tail_sampling:\n    decision_wait: 5s\n    policies:\n      - name: tracetest-spans\n        type: trace_state\n        trace_state: { key: tracetest, values: ["true"] }\n'})}),"\n",(0,s.jsx)(t.p,{children:"With this configuration, you will still get 5% of all your traces, but you will also ensure that all your test traces are collected and sent to\nJaeger."}),"\n",(0,s.jsx)(t.h2,{id:"consider-trace-related-headers-in-your-ingress-endpoint",children:"Consider Trace-related Headers in your Ingress Endpoint"}),"\n",(0,s.jsxs)(t.p,{children:["When exposing something to the internet, it's common to ignore all unknown headers from an HTTP request. This usually includes the ",(0,s.jsx)(t.code,{children:"traceparent"})," and ",(0,s.jsx)(t.code,{children:"tracestate"})," headers, which are the two headers defined in the ",(0,s.jsx)(t.a,{href:"https://www.w3.org/TR/trace-context/#relationship-between-the-headers",children:"W3C specification"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"However, supporting those two fields can be beneficial. For starters, you can start testing your application in production using Tracetest. If your product APIs are used directly by your customers, you can also share the same Trace-ID as them and use this to correlate a faulty operation on their side with your trace."})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(96540);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);