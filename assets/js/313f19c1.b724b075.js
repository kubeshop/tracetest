"use strict";(self.webpackChunktracetest_docs=self.webpackChunktracetest_docs||[]).push([[5822],{28774:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var n=s(74848),i=s(28453);const r={id:"creating-test-specifications",title:"Defining Test Specifications in Text Files",description:"Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},a=void 0,o={id:"cli/creating-test-specifications",title:"Defining Test Specifications in Text Files",description:"Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure.",source:"@site/docs/cli/creating-test-specifications.mdx",sourceDirName:"cli",slug:"/cli/creating-test-specifications",permalink:"/cli/creating-test-specifications",draft:!1,unlisted:!1,editUrl:"https://github.com/kubeshop/tracetest/blob/main/docs/docs/cli/creating-test-specifications.mdx",tags:[],version:"current",frontMatter:{id:"creating-test-specifications",title:"Defining Test Specifications in Text Files",description:"Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},sidebar:"tutorialSidebar",previous:{title:"Defining TraceID Tests as Text Files",permalink:"/cli/creating-tests-traceid"},next:{title:"Defining Test Outputs in Text Files",permalink:"/cli/creating-test-outputs"}},c={},l=[{value:"Assertions and Selectors",id:"assertions-and-selectors",level:2},{value:"Selectors",id:"selectors",level:3},{value:"Assertions",id:"assertions",level:3},{value:"Referencing Other Fields from the Same Span",id:"referencing-other-fields-from-the-same-span",level:4},{value:"Available Operations",id:"available-operations",level:2},{value:"Testing Span Events",id:"testing-span-events",level:2},{value:"Query breakdown",id:"query-breakdown",level:3}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Test Specifications may be added to a trace to set a value for a step in the trace to determine success or failure."}),"\n",(0,n.jsx)(t.h2,{id:"assertions-and-selectors",children:"Assertions and Selectors"}),"\n",(0,n.jsx)(t.p,{children:"Assertions are as important as how you trigger your test. Without them, your test is just a fancy way of executing a request using a CLI command. In this section, we will discuss how you can declare your assertions in your definition file."}),"\n",(0,n.jsx)(t.p,{children:"Before we start, there are two concepts that you must understand to write your tests:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/concepts/selectors",children:"Selectors"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/concepts/assertions",children:"Assertions"})}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"selectors",children:"Selectors"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Selectors"})," are queries that are executed against your trace tree and select a set of spans based on some attributes. They are responsible for defining which spans will be tested against your assertions."]}),"\n",(0,n.jsx)(t.h3,{id:"assertions",children:"Assertions"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Assertions"})," are tests against a specific span based on its attributes. A practical example might be useful:"]}),"\n",(0,n.jsxs)(t.p,{children:["Imagine you have to ensure that all your ",(0,n.jsx)(t.code,{children:"database select statements"})," take ",(0,n.jsx)(t.code,{children:"less than 500ms"}),". To write a test for that you must:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Select all spans in your trace related to ",(0,n.jsx)(t.code,{children:"select statements"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Check if all those spans lasted ",(0,n.jsx)(t.code,{children:"less than 500ms"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["For the first task, we use a selector: ",(0,n.jsx)(t.code,{children:'span[db.statement contains "SELECT"]'}),". While the second one is achieved by using an assertion: ",(0,n.jsx)(t.code,{children:"attr:tracetest.span.duration < 500ms"}),"."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Note:"})," When asserting time fields, you can use the following time units: ",(0,n.jsx)(t.code,{children:"ns"})," (nanoseconds), ",(0,n.jsx)(t.code,{children:"us"})," (microseconds), ",(0,n.jsx)(t.code,{children:"ms"})," (milliseconds), ",(0,n.jsx)(t.code,{children:"s"})," (seconds), ",(0,n.jsx)(t.code,{children:"m"})," (minutes), and ",(0,n.jsx)(t.code,{children:"h"})," (hours). Instead of defining ",(0,n.jsx)(t.code,{children:"attr:tracetest.span.duration <= 3600s"}),", you can set it as ",(0,n.jsx)(t.code,{children:"attr:tracetest.span.duration <= 1h"}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"To write that in your test definition, you can define the following YAML definition:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:'specs:\n- selector: span[db.statement contains "SELECT"]\n  assertions:\n    - attr:tracetest.span.duration < 500ms\n'})}),"\n",(0,n.jsx)(t.p,{children:"As you probably noticed in the test definition structure, you can have multiple assertions for the same selector. This is useful to group related validations. For example, ensuring that all your HTTP calls are successful and take less than 1000ms:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:'specs:\n- selector: span[tracetest.span.type="http"]\n  assertions:\n    - attr:http.status_code >= 200\n    - attr:http.status_code < 300\n    - attr:tracetest.span.duration < 1000ms\n'})}),"\n",(0,n.jsx)(t.h4,{id:"referencing-other-fields-from-the-same-span",children:"Referencing Other Fields from the Same Span"}),"\n",(0,n.jsx)(t.p,{children:"You also can reference fields from the same span in your assertions. For example, you can define an assertion to ensure the output number is greater than the input number."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:'specs:\n- selector: span[name = "my operation"]\n  assertions:\n    - attr:myapp.output > attr:myapp.input\n'})}),"\n",(0,n.jsx)(t.p,{children:"You also can use basic arithmetic expressions in your assertions:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"assertions:\n  - attr:myapp.output = myapp.input + 1\n"})}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["This does not take into account the order of operators yet. So an expression ",(0,n.jsx)(t.code,{children:"1 + 2 * 3"})," will be resolved as ",(0,n.jsx)(t.code,{children:"9"})," instead of ",(0,n.jsx)(t.code,{children:"7"}),". This will be fixed in future releases."]})}),"\n",(0,n.jsxs)(t.p,{children:["Available operations in an expression are: ",(0,n.jsx)(t.code,{children:"+"}),", ",(0,n.jsx)(t.code,{children:"-"}),", ",(0,n.jsx)(t.code,{children:"*"}),", and ",(0,n.jsx)(t.code,{children:"/"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"For more information about selectors or assertions, take a look at the documentation for those topics."}),"\n",(0,n.jsx)(t.h2,{id:"available-operations",children:"Available Operations"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"left"},children:"Operator"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"="})}),(0,n.jsx)(t.td,{children:"Check if two values are equal."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"!="})}),(0,n.jsx)(t.td,{children:"Check if two values have different values."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"<"})}),(0,n.jsx)(t.td,{children:"Check if value from left side is smaller than the one on the right side of the operation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"<="})}),(0,n.jsx)(t.td,{children:"Check if value from left side is smaller or equal to the one on the right side of the operation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:">"})}),(0,n.jsx)(t.td,{children:"Check if value from left side is larger than the one on the right side of the operation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:">="})}),(0,n.jsx)(t.td,{children:"Check if value from left side is larger or equal to the one on the right side of the operation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"contains"})}),(0,n.jsx)(t.td,{children:"Check if value on the right side of the operation is contained inside of the value of the left side of the operation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"left"},children:(0,n.jsx)(t.code,{children:"not-contains"})}),(0,n.jsx)(t.td,{children:"Check if value on the right side of the operation is not contained inside of the value of the left side of the operation."})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"testing-span-events",children:"Testing Span Events"}),"\n",(0,n.jsxs)(t.p,{children:["As an MVP of how to test span events, we are injecting ",(0,n.jsx)(t.code,{children:"all spans"})," events into the span attributes as a JSON array. To assert your span events, use the ",(0,n.jsx)(t.code,{children:"json_path"})," filter to select and test the ",(0,n.jsx)(t.strong,{children:"write events"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:'specs:\n  - selector: span[name = "my span"]\n    assertions:\n      - attr:span.events | json_path \'$[?(@.name = "event name")].attributes.key\' = "expected_value"\n'})}),"\n",(0,n.jsx)(t.h3,{id:"query-breakdown",children:"Query breakdown"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:'@.name = "event name"'}),': select the event with name "',(0,n.jsx)(t.strong,{children:"event name"}),'"']}),"\n",(0,n.jsxs)(t.li,{children:['$[?(@.name = "event name")]',(0,n.jsx)(t.strong,{children:".attributes.key"}),': select the attribute "',(0,n.jsx)(t.strong,{children:"key"}),'" from the event with name "',(0,n.jsx)(t.strong,{children:"event name"}),'"']}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(96540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);