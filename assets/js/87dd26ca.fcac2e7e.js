"use strict";(self.webpackChunktracetest_docs=self.webpackChunktracetest_docs||[]).push([[7728],{29126:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>c,toc:()=>d});var a=s(74848),i=s(28453);const n={id:"what-is-trace-based-testing",title:"What is Trace-Based Testing",description:"Trace-based testing is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},r=void 0,c={id:"concepts/what-is-trace-based-testing",title:"What is Trace-Based Testing",description:"Trace-based testing is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace.",source:"@site/docs/concepts/what-is-trace-based-testing.mdx",sourceDirName:"concepts",slug:"/concepts/what-is-trace-based-testing",permalink:"/concepts/what-is-trace-based-testing",draft:!1,unlisted:!1,editUrl:"https://github.com/kubeshop/tracetest/blob/main/docs/docs/concepts/what-is-trace-based-testing.mdx",tags:[],version:"current",frontMatter:{id:"what-is-trace-based-testing",title:"What is Trace-Based Testing",description:"Trace-based testing is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace.",keywords:["tracetest","trace-based testing","observability","distributed tracing","testing"],image:"https://res.cloudinary.com/djwdcmwdz/image/upload/v1698686403/docs/Blog_Thumbnail_14_rsvkmo.jpg"},sidebar:"tutorialSidebar",previous:{title:"Deployment Architecture",permalink:"/install/deployment-architecture"},next:{title:"Open Source vs Commercial Features",permalink:"/concepts/open-source-vs-commercial-features"}},o={},d=[{value:"Why Trace-based Testing?",id:"why-trace-based-testing",level:2},{value:"What is a Distributed Trace?",id:"what-is-a-distributed-trace",level:2},{value:"What is a Span?",id:"what-is-a-span",level:3},{value:"What Data do Spans Contain?",id:"what-data-do-spans-contain",level:3},{value:"What are Attributes?",id:"what-are-attributes",level:3},{value:"What is a Test Spec?",id:"what-is-a-test-spec",level:2},{value:"What is a Selector?",id:"what-is-a-selector",level:3},{value:"What is a Check?",id:"what-is-a-check",level:3},{value:"What is a Span Signature?",id:"what-is-a-span-signature",level:3}];function l(e){const t={a:"a",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Trace-based testing"})," is a means of conducting deep integration or system tests by utilizing the rich data contained in a distributed system trace."]}),"\n",(0,a.jsx)(t.h2,{id:"why-trace-based-testing",children:"Why Trace-based Testing?"}),"\n",(0,a.jsx)(t.p,{children:"In traditional testing, the focus is primarily on verifying that inputs and outputs match an expected result. While this approach is useful, it often overlooks critical issues such as race conditions, performance bottlenecks, failing interactions between services, broken 3rd party services, an many other issues."}),"\n",(0,a.jsx)(t.p,{children:"Trace-based testing validates entire application flows and transactions. It ensures that each step in the process is executed as intended as well as the final result. This is particularly important in microservices architectures, where complex interdependencies can make it difficult to detect and diagnose issues."}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Traditional Testing"}),(0,a.jsx)(t.th,{children:"Trace-based Testing"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Validates outputs"}),(0,a.jsx)(t.td,{children:"Validates entire transactions"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Limited to input/output validation"}),(0,a.jsx)(t.td,{children:"Detailed insight into each step in the transaction"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Can miss race conditions, bottlenecks, service-to-service interactions"}),(0,a.jsx)(t.td,{children:"Identifies race conditions, bottlenecks, etc."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Only suited for testing isolated components and functions"}),(0,a.jsx)(t.td,{children:"Ideal for testing full transactions in complex distributed systems and microservices"})]})]})]}),"\n",(0,a.jsx)(t.p,{children:"| Manual correlation of issues across components                         | Contextually links issues in a transaction                                           |\r\n| Cannot find issues caused by service dependencies                      | Finds and validates issues between services                                          |\r\n| Cannot find performance bottlenecks unless specifically tested         | Validates trace span duration and performance                                        |"}),"\n",(0,a.jsx)(t.h2,{id:"what-is-a-distributed-trace",children:"What is a Distributed Trace?"}),"\n",(0,a.jsxs)(t.p,{children:["A Distributed Trace, more commonly known as a Trace, records the paths taken by requests (made by an application or end-user) take as they propagate through multi-service architectures, like microservice and serverless applications. ",(0,a.jsx)(t.a,{href:"https://opentelemetry.io/docs/concepts/observability-primer/",children:"Source - OpenTelemetry.io"})]}),"\n",(0,a.jsxs)(t.p,{children:["In Tracetest, after selecting a test from the first screen and clicking on the ",(0,a.jsx)(t.strong,{children:"Trace"})," tab, you will see the distributed trace for the selected test:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Trace Example",src:s(96626).A+"",width:"2868",height:"1582"})}),"\n",(0,a.jsx)(t.h3,{id:"what-is-a-span",children:"What is a Span?"}),"\n",(0,a.jsx)(t.p,{children:"Traces are comprised of spans. A span represents a single operation in a trace. Spans are nested, typically with a parent child relationship to form a deeply nested tree."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Span Example",src:s(83047).A+"",width:"2874",height:"1592"})}),"\n",(0,a.jsx)(t.h3,{id:"what-data-do-spans-contain",children:"What Data do Spans Contain?"}),"\n",(0,a.jsx)(t.p,{children:"A span contains the data about the operation it represents. This data includes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The span name."}),"\n",(0,a.jsx)(t.li,{children:"Start and end timestamp."}),"\n",(0,a.jsx)(t.li,{children:"List of events (if instrumented)."}),"\n",(0,a.jsx)(t.li,{children:"Attributes"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"what-are-attributes",children:"What are Attributes?"}),"\n",(0,a.jsxs)(t.p,{children:["Attributes are a key-value pair, and they contain information about the operation. A developer can manually add additional attributes to a span, enriching the data. There are ",(0,a.jsx)(t.a,{href:"https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/",children:"Semantic Conventions"})," that provide recommended names for the attributes for common types of calls such as database, http, messaging, etc."]}),"\n",(0,a.jsx)(t.h2,{id:"what-is-a-test-spec",children:"What is a Test Spec?"}),"\n",(0,a.jsx)(t.p,{children:"In Tracetest, a Test Spec is comprised of two parts:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Selectors"}),"\n",(0,a.jsx)(t.li,{children:"Checks"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"what-is-a-selector",children:"What is a Selector?"}),"\n",(0,a.jsxs)(t.p,{children:["A selector contains criteria to limit the scope of the spans from a trace that we wish to assert against. A selector can be very narrow, only selecting on one span, or very wide, selecting all spans or all spans of a certain type or other characteristics. Underlying this capability is a ",(0,a.jsx)(t.a,{href:"/concepts/selectors",children:"selector language"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"what-is-a-check",children:"What is a Check?"}),"\n",(0,a.jsx)(t.p,{children:"A check is a logical verification that will be performed on all spans that match the selector. It is comprised of an attribute, a comparison operator and a value."}),"\n",(0,a.jsx)(t.h3,{id:"what-is-a-span-signature",children:"What is a Span Signature?"}),"\n",(0,a.jsx)(t.p,{children:"A span signature is an automatically computed selector that has enough elements to specify a single span. It uses a combination of attributes in the selected span to automatically build the selector. If a trace has multiple spans that are almost identical, the span signature may still match more than one span. You can alter the selector in this case to be more specific by adding other attributes or specifying an ancestor span."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},83047:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/span-example-e71e6c690b7c85e91ccceb47d53891ea.png"},96626:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/trace-example-4b8e9df276d5909dac8809ba620b5d1c.png"},28453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>c});var a=s(96540);const i={},n=a.createContext(i);function r(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);