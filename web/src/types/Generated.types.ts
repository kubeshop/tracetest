/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/tests": {
    /** get tests */
    get: operations["getTests"];
    /** Create new test action */
    post: operations["createTest"];
  };
  "/tests/{testId}": {
    /** get test */
    get: operations["getTest"];
    /** update test action */
    put: operations["updateTest"];
    /** delete a test */
    delete: operations["deleteTest"];
  };
  "/tests/{testId}/run": {
    /** run a particular test */
    post: operations["runTest"];
  };
  "/tests/{testId}/results/{resultId}": {
    /** get a particular test result */
    get: operations["getTestResult"];
    /** update test result state for a particular test */
    put: operations["updateTestResult"];
  };
  "/tests/{testId}/results": {
    /** get the results from a particular test */
    get: operations["getTestResults"];
  };
  "/tests/{testId}/assertions": {
    /** Gets all assertions associated to a particular test */
    get: operations["getAssertions"];
    /** Create an assertion for a particular test */
    post: operations["createAssertion"];
  };
  "/tests/{testId}/assertions/{assertionId}": {
    /** update an assertion */
    put: operations["updateAssertion"];
    /** delete an assertion */
    delete: operations["deleteAssertion"];
  };
}

export interface components {
  schemas: {
    Test: {
      /**
       * Format: uuid
       * @description ID
       */
      testId: string;
      name: string;
      description?: string;
      serviceUnderTest: {
        /**
         * Format: uuid
         * @description ID
         */
        id?: string;
        request?: components["schemas"]["HTTPRequest"];
      };
      /** @description Definition of assertions that are going to be made */
      assertions?: components["schemas"]["Assertion"][];
      referenceTestRunResult?: components["schemas"]["TestRunResult"];
    };
    Assertion: {
      /**
       * Format: uuid
       * @description ID
       */
      assertionId: string;
      selectors: components["schemas"]["SelectorItem"][];
      spanAssertions?: components["schemas"]["SpanAssertion"][];
    };
    TestRunResult: {
      /**
       * Format: uuid
       * @description ID
       */
      resultId: string;
      /**
       * Format: uuid
       * @description test ID
       */
      testId: string;
      /** @description trace ID */
      traceId?: string;
      /** @description parent span ID */
      spanId?: string;
      /**
       * @description Current execution state
       * @enum {string}
       */
      state:
        | "CREATED"
        | "EXECUTING"
        | "AWAITING_TRACE"
        | "FAILED"
        | "FINISHED"
        | "AWAITING_TEST_RESULTS";
      /** @description Details of the cause for the last `FAILED` state */
      lastErrorState?: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      completedAt?: string;
      /** @description TODO(pov) This is HTTP Response object for now, at some point it might be GRPC/SOAP/... */
      response?: components["schemas"]["HTTPResponse"];
      trace?: external["trace.yaml"]["components"]["schemas"]["Trace"];
      /** @description True if all trace spans passed the assertion test */
      assertionResultState?: boolean;
      /** @description List of all tested span assertions */
      assertionResult?: components["schemas"]["AssertionResult"][];
    };
    TestAssertionResult: {
      /** @description True if all trace spans passed the assertion test */
      assertionResultState?: boolean;
      /** @description List of all tested span assertions */
      assertionResult?: components["schemas"]["AssertionResult"][];
    };
    Attribute: {
      /** @description ID */
      id: string;
      key: string;
      value: string;
    };
    SelectorItem: {
      /**
       * @description Example "SPAN"
       * @enum {string}
       */
      locationName:
        | "RESOURCE_ATTRIBUTES"
        | "INSTRUMENTATION_LIBRARY"
        | "SPAN"
        | "SPAN_ATTRIBUTES";
      /** @description Example "operation" */
      propertyName: string;
      /** @description Example "POST /users/verify" */
      value: string;
      /** @enum {string} */
      valueType:
        | "stringValue"
        | "intValue"
        | "boolValue"
        | "doubleValue"
        | "kvlistValue";
    };
    SpanAssertion: {
      /** @description ID */
      spanAssertionId: string;
      /**
       * @description Example "SPAN_ATTRIBUTES"
       * @enum {string}
       */
      locationName:
        | "RESOURCE_ATTRIBUTES"
        | "INSTRUMENTATION_LIBRARY"
        | "SPAN"
        | "SPAN_ATTRIBUTES";
      /** @description Example "http.status.code" */
      propertyName: string;
      /**
       * @description Example "intValue"
       * @enum {string}
       */
      valueType:
        | "stringValue"
        | "intValue"
        | "boolValue"
        | "doubleValue"
        | "kvlistValue";
      /**
       * @description Example "EQUALS"
       * @enum {string}
       */
      operator:
        | "EQUALS"
        | "NOTEQUALS"
        | "LESSTHAN"
        | "GREATERTHAN"
        | "GREATOREQUALS"
        | "LESSOREQUAL"
        | "CONTAINS";
      /** @description Example "200" */
      comparisonValue: string;
    };
    HTTPResponse: {
      status?: string;
      statusCode?: number;
      headers?: {
        key?: string;
        value?: string;
      }[];
      /** Format: byte */
      body?: string;
    };
    AssertionResult: {
      /** @description ID */
      assertionId: string;
      spanAssertionResults: components["schemas"]["SpanAssertionResult"][];
    };
    SpanAssertionResult: {
      /** @description ID */
      spanAssertionId: string;
      /** @description ID */
      spanId: string;
      /** @description True if the span passed the assertion test */
      passed: boolean;
      /** @description value that the trace for this test run contained */
      observedValue: string;
    };
    HTTPRequest: {
      url?: string;
      /** @enum {string} */
      method?:
        | "GET"
        | "PUT"
        | "POST"
        | "PATCH"
        | "DELETE"
        | "COPY"
        | "HEAD"
        | "OPTIONS"
        | "LINK"
        | "UNLINK"
        | "PURGE"
        | "LOCK"
        | "UNLOCK"
        | "PROPFIND"
        | "VIEW";
      headers?: {
        key?: string;
        value?: string;
      }[];
      /** Format: byte */
      body?: string;
      auth?: components["schemas"]["HTTPAuth"];
      /** @description TODO */
      proxy?: { [key: string]: unknown };
      /** @description TODO */
      certificate?: { [key: string]: unknown };
    };
    HTTPAuth: {
      /** @enum {string} */
      type?: "apiKey" | "basic" | "bearer";
      apiKey?: {
        key?: string;
        value?: string;
        /** @enum {string} */
        in?: "query" | "header";
      };
      basic?: {
        username?: string;
        password?: string;
      };
      bearer?: {
        token?: string;
      };
    };
  };
}

export interface operations {
  /** get tests */
  getTests: {
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["Test"][];
        };
      };
      /** problem with getting tests */
      500: unknown;
    };
  };
  /** Create new test action */
  createTest: {
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["Test"];
        };
      };
      /** problem with creating test */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Test"];
      };
    };
  };
  /** get test */
  getTest: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["Test"];
        };
      };
      /** problem with getting a test */
      500: unknown;
    };
  };
  /** update test action */
  updateTest: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** successful operation */
      204: never;
      /** problem with updating test */
      500: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Test"];
      };
    };
  };
  /** delete a test */
  deleteTest: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** OK */
      204: never;
    };
  };
  /** run a particular test */
  runTest: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["TestRunResult"];
        };
      };
    };
  };
  /** get a particular test result */
  getTestResult: {
    parameters: {
      path: {
        testId: string;
        resultId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["TestRunResult"];
        };
      };
    };
  };
  /** update test result state for a particular test */
  updateTestResult: {
    parameters: {
      path: {
        testId: string;
        resultId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["TestRunResult"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TestAssertionResult"];
      };
    };
  };
  /** get the results from a particular test */
  getTestResults: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["TestRunResult"][];
        };
      };
    };
  };
  /** Gets all assertions associated to a particular test */
  getAssertions: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** successful operation */
      200: {
        content: {
          "application/json": components["schemas"]["Assertion"][];
        };
      };
    };
  };
  /** Create an assertion for a particular test */
  createAssertion: {
    parameters: {
      path: {
        testId: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Assertion"];
      };
    };
  };
  /** update an assertion */
  updateAssertion: {
    parameters: {
      path: {
        testId: string;
        assertionId: string;
      };
    };
    responses: {
      /** OK */
      204: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["Assertion"];
      };
    };
  };
  /** delete an assertion */
  deleteAssertion: {
    parameters: {
      path: {
        testId: string;
        assertionId: string;
      };
    };
    responses: {
      /** OK */
      204: never;
    };
  };
}

export interface external {
  "trace.yaml": {
    paths: {};
    components: {
      schemas: {
        /**
         * @description Event is a time-stamped annotation of the span, consisting of user-supplied
         * text description and key-value pairs.
         */
        SpanEvent: {
          /**
           * Format: uint64
           * @description time_unix_nano is the time the event occurred.
           */
          timeUnixNano: string;
          /**
           * @description name of the event.
           * This field is semantically required to be set to non-empty string.
           */
          name: string;
          /**
           * @description attributes is a collection of attribute key/value pairs on the event.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           */
          attributes: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
          /**
           * Format: int64
           * @description dropped_attributes_count is the number of dropped attributes. If the value is 0,
           * then no attributes were dropped.
           */
          droppedAttributesCount?: number;
        };
        /**
         * @description A pointer from the current span to another span in the same trace or in a
         * different trace. For example, this can be used in batching operations,
         * where a single batch handler processes multiple requests from different
         * traces or when the handler receives a request from a different project.
         */
        SpanLink: {
          /**
           * Format: byte
           * @description A unique identifier of a trace that this linked span is part of. The ID is a
           * 16-byte array.
           */
          traceId?: string;
          /**
           * Format: byte
           * @description A unique identifier for the linked span. The ID is an 8-byte array.
           */
          spanId: string;
          /** @description The trace_state associated with the link. */
          traceState: string;
          /**
           * @description attributes is a collection of attribute key/value pairs on the link.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           */
          attributes: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
          /**
           * Format: int64
           * @description dropped_attributes_count is the number of dropped attributes. If the value is 0,
           * then no attributes were dropped.
           */
          droppedAttributesCount?: number;
        };
        /**
         * @description SpanKind is the type of span. Can be used to specify additional relationships between spans
         * in addition to a parent/child relationship.
         *
         * - SPAN_KIND_UNSPECIFIED: Unspecified. Do NOT use as default.
         * Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
         * - SPAN_KIND_INTERNAL: Indicates that the span represents an internal operation within an application,
         * as opposed to an operation happening at the boundaries. Default value.
         * - SPAN_KIND_SERVER: Indicates that the span covers server-side handling of an RPC or other
         * remote network request.
         * - SPAN_KIND_CLIENT: Indicates that the span describes a request to some remote service.
         * - SPAN_KIND_PRODUCER: Indicates that the span describes a producer sending a message to a broker.
         * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
         * between producer and consumer spans. A PRODUCER span ends when the message was accepted
         * by the broker while the logical processing of the message might span a much longer time.
         * - SPAN_KIND_CONSUMER: Indicates that the span describes consumer receiving a message from a broker.
         * Like the PRODUCER kind, there is often no direct critical path latency relationship
         * between producer and consumer spans.
         * @default SPAN_KIND_UNSPECIFIED
         * @enum {string}
         */
        SpanSpanKind:
          | "SPAN_KIND_UNSPECIFIED"
          | "SPAN_KIND_INTERNAL"
          | "SPAN_KIND_SERVER"
          | "SPAN_KIND_CLIENT"
          | "SPAN_KIND_PRODUCER"
          | "SPAN_KIND_CONSUMER";
        /**
         * For the semantics of status codes see
         * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
         * @description - STATUS_CODE_UNSET: The default status.
         * - STATUS_CODE_OK: The Span has been validated by an Application developers or Operator to have
         * completed successfully.
         * - STATUS_CODE_ERROR: The Span contains an error.
         * @default STATUS_CODE_UNSET
         * @enum {string}
         */
        StatusStatusCode:
          | "STATUS_CODE_UNSET"
          | "STATUS_CODE_OK"
          | "STATUS_CODE_ERROR";
        /** @description Response object with spans. */
        Trace: {
          description?: string;
          /**
           * A list of OpenTelemetry ResourceSpans.
           * In case of JSON format the ids (trace_id, span_id, parent_id) are encoded in base64 even though OpenTelemetry specification
           * mandates to use hex encoding [2].
           * Base64 is chosen to keep compatibility with JSONPb codec.
           * [1]: https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto
           * [2]: https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/protocol/otlp.md#otlphttp
           */
          resourceSpans: external["trace.yaml"]["components"]["schemas"]["ResourceSpans"][];
        };
        /**
         * @description AnyValue is used to represent any type of attribute value. AnyValue may contain a
         * primitive value such as a string or integer or it may contain an arbitrary nested
         * object containing arrays, key-value lists and primitives.
         */
        AttributeValue: {
          stringValue?: string;
          boolValue?: boolean;
          /** Format: int64 */
          intValue?: string;
          /** Format: double */
          doubleValue?: number;
          arrayValue?: external["trace.yaml"]["components"]["schemas"]["AttributeArray"];
          kvlistValue?: external["trace.yaml"]["components"]["schemas"]["AttributeKvlistValue"];
          /** Format: byte */
          bytesValue?: string;
        };
        /**
         * @description ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
         * since oneof in AnyValue does not allow repeated fields.
         */
        AttributeArray: {
          /** @description Array of values. The array may be empty (contain 0 elements). */
          values: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
        };
        /**
         * @description InstrumentationLibrary is a message representing the instrumentation library information
         * such as the fully qualified name and version.
         */
        InstrumentationLibrary: {
          /** @description An empty instrumentation library name means the name is unknown. */
          name: string;
          version: string;
        };
        /** @description A collection of Spans produced by an InstrumentationLibrary. */
        InstrumentationLibrarySpans: {
          /**
           * @description The instrumentation library information for the spans in this message.
           * Semantically when InstrumentationLibrary isn't set, it is equivalent with
           * an empty instrumentation library name (unknown).
           */
          instrumentationLibrary: external["trace.yaml"]["components"]["schemas"]["InstrumentationLibrary"];
          /** @description A list of Spans that originate from an instrumentation library. */
          spans: external["trace.yaml"]["components"]["schemas"]["Span"][];
          /** @description This schema_url applies to all spans and span events in the "spans" field. */
          schemaUrl?: string;
        };
        /**
         * @description KeyValue is a key-value pair that is used to store Span attributes, Link
         * attributes, etc.
         */
        Attribute: {
          key: string;
          value: external["trace.yaml"]["components"]["schemas"]["AttributeValue"];
        };
        /**
         * @description KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
         * since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
         * a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
         * avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
         * are semantically equivalent.
         */
        AttributeKvlistValue: {
          /**
           * @description A collection of key/value pairs of key-value pairs. The list may be empty (may
           * contain 0 elements).
           * The keys MUST be unique (it is not allowed to have more than one
           * value with the same key).
           */
          values: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
        };
        /** @description Resource information. */
        Resource: {
          /**
           * @description Set of attributes that describe the resource.
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           */
          attributes: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
          /**
           * Format: int64
           * @description dropped_attributes_count is the number of dropped attributes. If the value is 0, then
           * no attributes were dropped.
           */
          droppedAttributesCount?: number;
        };
        /** @description A collection of InstrumentationLibrarySpans from a Resource. */
        ResourceSpans: {
          /**
           * @description The resource for the spans in this message.
           * If this field is not set then no resource info is known.
           */
          resource: external["trace.yaml"]["components"]["schemas"]["Resource"];
          /** @description A list of InstrumentationLibrarySpans that originate from a resource. */
          instrumentationLibrarySpans: external["trace.yaml"]["components"]["schemas"]["InstrumentationLibrarySpans"][];
          /**
           * @description This schema_url applies to the data in the "resource" field. It does not apply
           * to the data in the "instrumentation_library_spans" field which have their own
           * schema_url field.
           */
          schemaUrl?: string;
        };
        /**
         * @description Span represents a single operation within a trace. Spans can be
         * nested to form a trace tree. Spans may also be linked to other spans
         * from the same or different trace and form graphs. Often, a trace
         * contains a root span that describes the end-to-end latency, and one
         * or more subspans for its sub-operations. A trace can also contain
         * multiple root spans, or none at all. Spans do not need to be
         * contiguous - there may be gaps or overlaps between spans in a trace.
         *
         * The next available field id is 17.
         */
        Span: {
          /**
           * Format: byte
           * @description A unique identifier for a trace. All spans from the same trace share
           * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes
           * is considered invalid.
           *
           * This field is semantically required. Receiver should generate new
           * random trace_id if empty or invalid trace_id was received.
           *
           * This field is required.
           */
          traceId: string;
          /**
           * Format: byte
           * @description A unique identifier for a span within a trace, assigned when the span
           * is created. The ID is an 8-byte array. An ID with all zeroes is considered
           * invalid.
           *
           * This field is semantically required. Receiver should generate new
           * random span_id if empty or invalid span_id was received.
           *
           * This field is required.
           */
          spanId: string;
          /**
           * @description trace_state conveys information about request position in multiple distributed tracing graphs.
           * It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
           * See also https://github.com/w3c/distributed-tracing for more details about this field.
           */
          traceState: string;
          /**
           * Format: byte
           * @description The `span_id` of this span's parent span. If this is a root span, then this
           * field must be empty. The ID is an 8-byte array.
           */
          parentSpanId: string;
          /**
           * @description A description of the span's operation.
           *
           * For example, the name can be a qualified method name or a file name
           * and a line number where the operation is called. A best practice is to use
           * the same display name at the same call point in an application.
           * This makes it easier to correlate spans in different traces.
           *
           * This field is semantically required to be set to non-empty string.
           * Empty value is equivalent to an unknown span name.
           *
           * This field is required.
           */
          name: string;
          /**
           * @description Distinguishes between spans generated in a particular context. For example,
           * two spans with the same name may be distinguished using `CLIENT` (caller)
           * and `SERVER` (callee) to identify queueing latency associated with the span.
           */
          kind: external["trace.yaml"]["components"]["schemas"]["SpanSpanKind"];
          /**
           * Format: uint64
           * @description start_time_unix_nano is the start time of the span. On the client side, this is the time
           * kept by the local machine where the span execution starts. On the server side, this
           * is the time when the server's application handler starts running.
           * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
           *
           * This field is semantically required and it is expected that end_time >= start_time.
           */
          startTimeUnixNano: string;
          /**
           * Format: uint64
           * @description end_time_unix_nano is the end time of the span. On the client side, this is the time
           * kept by the local machine where the span execution ends. On the server side, this
           * is the time when the server application handler stops running.
           * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
           *
           * This field is semantically required and it is expected that end_time >= start_time.
           */
          endTimeUnixNano: string;
          /**
           * attributes is a collection of key/value pairs. Note, global attributes
           * like server name can be set using the resource API. Examples of attributes:
           * @description "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
           *     "/http/server_latency": 300
           *     "abc.com/myattribute": true
           *     "abc.com/score": 10.239
           *
           * The OpenTelemetry API specification further restricts the allowed value types:
           * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/common.md#attributes
           * Attribute keys MUST be unique (it is not allowed to have more than one
           * attribute with the same key).
           */
          attributes: external["trace.yaml"]["components"]["schemas"]["Attribute"][];
          /**
           * Format: int64
           * @description dropped_attributes_count is the number of attributes that were discarded. Attributes
           * can be discarded because their keys are too long or because there are too many
           * attributes. If this value is 0, then no attributes were dropped.
           */
          droppedAttributesCount?: number;
          /** @description events is a collection of Event items. */
          events?: external["trace.yaml"]["components"]["schemas"]["SpanEvent"][];
          /**
           * Format: int64
           * @description dropped_events_count is the number of dropped events. If the value is 0, then no
           * events were dropped.
           */
          droppedEventsCount?: number;
          /**
           * @description links is a collection of Links, which are references from this span to a span
           * in the same or different trace.
           */
          links?: external["trace.yaml"]["components"]["schemas"]["SpanLink"][];
          /**
           * Format: int64
           * @description dropped_links_count is the number of dropped links after the maximum size was
           * enforced. If this value is 0, then no links were dropped.
           */
          droppedLinksCount?: number;
          /**
           * @description An optional final status for this span. Semantically when Status isn't set, it means
           * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
           */
          status: external["trace.yaml"]["components"]["schemas"]["Status"];
        };
        /**
         * @description The Status type defines a logical error model that is suitable for different
         * programming environments, including REST APIs and RPC APIs.
         */
        Status: {
          /** @description A developer-facing human readable error message. */
          message?: string;
          /** @description The status code. */
          code?: external["trace.yaml"]["components"]["schemas"]["StatusStatusCode"];
        };
      };
    };
    operations: {};
  };
}
