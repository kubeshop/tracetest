# Transactions

Most End-to-End tests are not simple to run. They require some setup before the actual test is run. Actions like creating a new user, removing all items from a cart, etc. It is important that you can execute multiple steps as part of your test suite. Tracetest introduces the concept of **Transactions** to achieve this goal.

## What is a Transaction?
A transaction is defined as a group of steps that are executed in the defined order and can access information exported by previous step executions. Each step is a test.

## Chaining Tests
The main benefit of using transactions is to chain tests together and use values obtained from a test in a subsequent test.

### How Values are Shared by Tests
When a transaction is run, a context object is created with information about that specific run. One of those pieces of information is an `environment variables` object, which is empty by default. If the transaction is run when referencing an [environment](./environments), all values from the selected environments will be copied to the `environment variables` object.

When a test is executed within a transaction, if it generates any outputs, its outputs will be injected into the transaction context environment variables object. After the outputs are injected, all subsequent tests to be run within the transaction will be able to reference those values.

> :information_source: Outputs generated by steps don't modify the selected [environment](./environments). It only modifies the transaction run context object.

Consider you have 3 tests within a transaction: A, B, and C. Tests A and B generate outputs called A_OUTPUT and B_OUTPUT, respectively. When running the transaction, we provide an environment which contains a `HOST` environment variable. The execution of test A would only be able to reference `env:HOST`. B would be able to reference `env:HOST`, and `env:A_OUTPUT`. While C would be able to reference all three environment variables: `env:HOST`, `env:A_OUTPUT`, `env:B_OUTPUT`.

> :information_source: A single test can contain as many outputs as you like.

### Exposing Values from a Test to Other Tests
Since version v0.8, Tracetest allows tests to declare `outputs`. An output is a value that is extracted from a trace by providing a [selector](./selectors) to choose which spans to use to get the information from, and an [expression](./expressions) to get the value from the selected spans. For example, consider that you want to expose the time a specific job was taken from a queue and began executing. An output would look something like the following:

```yaml
outputs:
    - name: TIME_CANCEL_SUBSCRIPTION_MESSAGE_OBTAINED
      selector: span[name = "Process request from cancel subscription queue"]
      expression: attr:tracetest.time.start
```

This would create an output called `TIME_CANCEL_SUBSCRIPTION_MESSAGE_OBTAINED` that is obtained by reading the attribute `tracetest.time.start` from the span with `name` equal to `Process request from cancel subscription queue`. This value would would then be injected into the environment variables of that transaction to be accessed by other tests within the same transaction run.

### Transactions Execution Flow

Transaction steps are executed sequentially. A next step is only executed after the previous step finishes executing successfully. A successful step is one which managed to trigger an operation and received a trace back from the data store. Failing assertions do not stop a transaction from executing the next steps.

Examples:

### Transaction where one step didn't get executed:

* Step 1 (Finished)
* Step 2 (Failed to fetch trace)
* Step 3 (not executed)

Result: **FAILED**

### Transaction where all steps were executed, but the assertions failed:
* Step 1 (Finished)
* Step 2 (Finished)
* Step 3 (Failed assertions)

Result: **FAILED**

### Transaction where all steps succeeded:
* Step 1 (Finished)
* Step 2 (Finished)
* Step 3 (Finished)

Result: **FINISHED**
