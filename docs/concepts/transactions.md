# Transactions

Most of End-to-End tests are not simple to run. They require some setup before the actual test is run. Maybe you have to create a new user, remove all items from a cart, etc. So it's important for you that you can execute multiple steps as part of your test suite. Tracetest introduces the concept of Transactions to achieve this goal.

## What is a transaction
A transaction is defined as a group of steps that are executed in the defined order and can access information exported by previous step executions. Each step is a test.

## Chaining tests
The main benefit of using transactions is to be able to chaining tests together and use values obtained from a test in a subsequent test.

### How values are shared by tests
When a transaction is run, a context object is created with several informations about that specific run. One of those informations is an `environment variables` object which is empty by default. In case you run the transaction when referencing an [environment](environments.md), all values from the selected environments will be copied to the `environment variables` object.

When a test is executed within a transaction, if it generates any outputs, its outputs will be injected into the transaction context environment variables object. After the outputs are injected, all subsequent tests to be run within the transaction will be able to reference those values.

> :information_source: Outputs generated by steps don't modify the selected [environment](environments.md). It only modifies the transaction run context object.

Consider you have 3 tests within a transaction: A, B, and C. Both A and B generate outputs called A_OUTPUT and B_OUTPUT respectively. And when running the transaction, we provide an environment which contain a `HOST` environment variable. The execution of test A would only be able to reference `env:HOST`. B would be able to reference `env:HOST`, and `env:A_OUTPUT`. While C would be able to reference all three environment variables: `env:HOST`, `env:A_OUTPUT`, `env:B_OUTPUT`.

> :information_source: A single test can contain as many outputs as you like.

### Exposing values from a test to other tests
Since version v0.8, Tracetest allows tests to declare `outputs`. An output is a value that is extracted from a trace by providing it a [selector](selectors.md) to choose which spans to use to get the information from and an [expression](../expressions.md) to get the value from the selected spans. For example, consider that you want to expose the time a specific job was taken from a queue and began executing. An output would look something like the following:

```yaml
outputs:
    - name: TIME_CANCEL_SUBSCRIPTION_MESSAGE_OBTAINED
      selector: span[name = "Process request from cancel subscription queue"]
      expression: attr:tracetest.time.start
```

This would create an output called `TIME_CANCEL_SUBSCRIPTION_MESSAGE_OBTAINED` that is obtained by reading the attribute `tracetest.time.start` from the span with `name` equals to `Process request from cancel subscription queue`. This value would would then be injected into the environment variables of that transaction to be accessed by other tests within the same transaction run.

### Transactions execution flow

Transaction steps are executed sequentially. A next step is only executed after the previous step finished executing and it is successful. A successful step is considered a step which managed to trigger an operation and got a trace back from the data store. Failing assertions do not make a transaction stop executing the next steps.

Examples:

### Transaction which one step didn't get executed

* Step 1 (Finished)
* Step 2 (Failed to fetch trace)
* Step 3 (not executed)

Result: **FAILED**

### Transaction which all steps were executed, but they assertions failed
* Step 1 (Finished)
* Step 2 (Finished)
* Step 3 (Failed assertions)

Result: **FAILED**

### Transaction which all steps succeded
* Step 1 (Finished)
* Step 2 (Finished)
* Step 3 (Finished)

Result: **FINISHED**
