# Defining tests as text files

One important aspect of testing your code is the ability of adapting fast to changes while don't breaking your application. So, it is important that if you change your application, you are able to update your tests and run them against your new implementation as soon as possible to have a nice development feedback loop.

As Tracetest is mainly a visual tool, this might make it difficult to update tests in an auditable way and executing those changes only when we are sure the application has being deployed with our changes. With that in mind, we build a new way for you to define your tests: using a YAML test definition!

## Motivation

Imagine that you were assigned to a ticket to improve your application database usage. You notice that everytime a specific endpoint is called, your application executes `N+1` select statements on the database instead of only one statement. You probably already have a test in place to ensure the correct functionality of that endpoint: it sets the necessary information up to be present in the database and then call that specific endpoint using our tool and ensure you get the expected results using the trace generated by your application. It works fine, but there is a problem. That test is managed by Tracetest on its server and I cannot change the test until my patch is deployed, otherwise, if anyone tries to run that test using a non-patched version of the application, the test would fail.

To solve that, the best approach would be enable developers to define their tests as text files and allow them to run those tests using a CLI. So you can integrate the execution of those tests to your existing CI pipeline. This brings a lot of benefits for your tests: now your peers can review your tests before merging them to the main branch, you can ensure your test works before merging it to the main branch, you can have different versions of the same test running in parallel in different branches, so you and your peers can work on the same code modules and updating the same test without interfering with each other.

## Definition

Right now the definition can be broken into three parts: `test information`, `triggering transaction`, and `assertions`. Here is a real test we have on tracetest to test our pokemon demo api:

```yaml
name: POST import pokemon
trigger:
  type: http
  http_request:
    url: http://demo-pokemon-api.demo/pokemon/import
    method: POST
    headers:
    - key: Content-Type
      value: application/json
    body:
      type: raw
      raw: '{ "id": 52 }'
testDefinition:
- selector: span[name = "POST /pokemon/import"]
  assertions:
  - tracetest.span.duration <= 500
  - http.status_code = 200
- selector: span[name = "send message to queue"]
  assertions:
  - messaging.message.payload contains 52
- selector: span[name = "consume message from queue"]:last
  assertions:
  - messaging.message.payload contains 52
- selector: span[name = "consume message from queue"]:last span[name = "import pokemon
    from pokeapi"]
  assertions:
  - http.status_code = 200
- selector: span[name = "consume message from queue"]:last span[name = "save pokemon
    on database"]
  assertions:
  - db.repository.operation = "create"
  - tracetest.span.duration <= 500
```

## Test information
Right now you can only define the test name.

## Trigger
This section defines how Tracetest will interact with your application. Will it send a HTTP request, a GRPC call, send a message to a message broker, etc. For now, we only support HTTP calls, but let us know any other triggering mechanism that you might need to be able to test your application.

The attribute `type` defines which trigger method you are going to use to interact with your application. The rest of the attributes of this section rely on the value you define there.

### HTTP trigger
When defining a HTTP trigger, you are required to define a `http_request` object containing the request Tracetest will send to your system, so here you can define: `url`, `method`, `headers`, `authentication`, and `body`.

> :warning: Note: Some APIs require the `Content-Type` header to respond. If you are not being able to trigger your application, check if you are sending this header and if its value is correct.

> :warning: Note: For now, we only support `raw` body formats. We will add support to other types of bodies in the future. Let us know if you need a specific one by opening an issue.

```yaml
trigger:
  type: http
  http_request:
    url: http://demo-pokemon-api.demo/pokemon/import
    method: POST
    headers:
    - key: Content-Type
      value: application/json
    body:
      type: raw
      raw: '{ "id": 52 }'
```

#### Authentication
Currently, we support three authentication methods for HTTP requests: `basic authentication`, `api key`, and `bearer token`. Here are one example of each authentication method:

**Basic Authentication**
```yaml
trigger:
    type: http
    http_request:
        url: http://my-api.com
        method: GET
        authentication:
            type: basic
            basicAuth:
                user: my-username
                password: mypassword
```

**API Key Authentication**
```yaml
trigger:
    type: http
    http_request:
        url: http://my-api.com
        method: GET
        authentication:
            type: apiKey
            apiKey:
                key: X-Key
                value: my-key
                in: header # Either "header" or "query"
```

**Bearer Token authentication**
```yaml
trigger:
    type: http
    http_request:
        url: http://my-api.com
        method: GET
        authentication:
            type: bearer
            bearer:
                token: my-token
```

#### Body

Right now we are only supporting `raw` body types. That basically enables you to send text formats over HTTP, for example: JSON.

```yaml
trigger:
    type: http
    http_request:
        url: http://my-api.com
        method: POST
        body:
            type: raw
            raw: '{"name": "my Json Object"}'
```

### Assertions
Assertions are as important as how you trigger your test. Without them, your test is just a fancy way of executing a request using a CLI command. In this section, we will discuss how you can declare your assertions in your definition file.

Before we start, there are two concepts that you must understand to write your tests: [selectors](https://kubeshop.github.io/tracetest/advanced-selectors/), and assertions. Basically, selectors are queries that are executed against your trace tree and select a set of spans based on some attributes. They are responsible to define which spans will be tested against your assertions. Assertions are tests against a specific span based on its attributes. A pratical example might be useful to make you understand it:

Imagine you have to ensure that all your `database select statements` take `less than 500ms`, to write a test for that you must:

1. Select all spans in your trace related to `select statements`
2. Check if all those spans lasted `less than 500ms`

For the first task, we use a selector: `span[db.statement contains "SELECT"]`. While the second one is achieved by using an assertion: `tracetest.span.duration < 500`.

So, to write that in your test definition, you can define the following YAML definition:

```yaml
testDefinition:
    - selector: span[db.statement contains "SELECT"]
      assertions:
        - tracetest.span.duration < 500
```

As you probably noticed in the test definition structure, you can have multiple assertions for the same selector. This is useful to group related validations. For example, ensuring that all your HTTP calls are successful and take less than 1000ms:

```yaml
testDefinition:
    - selector: span[tracetest.span.type="http"]
      assertions:
        - http.status_code >= 200
        - http.status_code < 300
        - tracetest.span.duration < 1000
``` 

For more information about selectors or assertions, take a look at the documentation of those topics.